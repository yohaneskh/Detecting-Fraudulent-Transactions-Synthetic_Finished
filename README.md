# Detecting-Fraudulent-Transactions-Synthetic_Finished

This project analyzes a synthetic dataset generated by the **PaySim Mobile Money Simulator**, designed to emulate real-world financial transactions in a mobile money platform.

---

## ğŸ“Š Objective

To build a supervised **Machine Learning model** capable of identifying fraudulent transactions based on historical transaction data.

---

## ğŸ“ Dataset Overview

- **Source**: PaySim (via Kaggle)
- **Size**: ~6 million rows (30-day simulation)
- **Each row**: Represents a single mobile money transaction.

### ğŸ”‘ Key Features:

- `step`: Time unit (1 hour per step), total 744 steps (30 days).
- `type`: Transaction types â€“ CASH-IN, CASH-OUT, DEBIT, PAYMENT, TRANSFER.
- `amount`: Transaction amount.
- `nameOrig` / `nameDest`: Sender and recipient IDs.
- `oldbalanceOrg` / `newbalanceOrig`: Sender's balance before and after.
- `oldbalanceDest` / `newbalanceDest`: Recipient's balance before and after.
- `isFraud`: Target label (1 = fraud, 0 = non-fraud).
- `isFlaggedFraud`: Flag if the transaction exceeds 200,000 units.

> âš ï¸ Note:
> - Balance info is missing for merchants (IDs starting with 'M').
> - Fraudsters typically move money via TRANSFER followed by CASH-OUT.
> - Flagged frauds simulate detection of unusually large transfers.

---

## ğŸ› ï¸ Tools & Technologies

- Python (Google Colab)
- Libraries: `pandas`, `numpy`, `matplotlib`, `seaborn`, `scikit-learn`, `imbalanced-learn`, `Optuna`, `XGBoost`, `LightGBM`, `CatBoost`

---

## âš™ï¸ Models and Techniques

- **SMOTE**: Synthetic Minority Oversampling to handle class imbalance
- **XGBoost**, **LightGBM**, **CatBoost**: Gradient Boosting models
- **Optuna**: Automated hyperparameter tuning
- **Early Stopping & Pruning Callbacks**: For efficient training

---

## ğŸ§ª Evaluation Metrics

- **Precision**
- **Recall**
- **F1-Score**
- **AUC-ROC**
- **PR-AUC**

---

## ğŸ” How to Use This Notebook

1. Open the notebook in **Google Colab**
2. Mount your Google Drive:
   ```python
   from google.colab import drive
   drive.mount('/content/drive')
